<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Rustmania</title><link href="https://KieranHunt.github.io/" rel="alternate"></link><link href="https://KieranHunt.github.io/feeds/rust.atom.xml" rel="self"></link><id>https://KieranHunt.github.io/</id><updated>2015-07-26T11:30:00+02:00</updated><entry><title>Loop Labels</title><link href="https://KieranHunt.github.io/loop-labels.html" rel="alternate"></link><updated>2015-07-26T11:30:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-26:loop-labels.html</id><summary type="html">&lt;p&gt;Assigning labels to your loops can be very helpful. Generally you would use labels as a way of breaking out of some outer loop from within an inner loop. Without named loops doing that sort of thing would require a return statement or some kind of &lt;code&gt;if/else&lt;/code&gt; gymnastics.&lt;/p&gt;
&lt;p&gt;The syntax for a loop label closely resembles Rust's &lt;a href="https://doc.rust-lang.org/book/lifetimes.html"&gt;lifetimes&lt;/a&gt;. An example of loop labels is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fn main() {
    &amp;#39;outer: loop {
        println!(&amp;quot;Entered the outer loop&amp;quot;);

        &amp;#39;inner: loop {
            println!(&amp;quot;Entered the inner loop&amp;quot;);

            // This would break only the inner loop
            //break;

            // This breaks the outer loop
            break &amp;#39;outer;
        }

        println!(&amp;quot;This point will never be reached&amp;quot;);
    }

    println!(&amp;quot;Exited the outer loop&amp;quot;);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Code adapted from &lt;a href="http://rustbyexample.com/flow_control/loop/nested.html"&gt;this page&lt;/a&gt; from the excellent &lt;a href="http://rustbyexample.com/"&gt;Rust by Example&lt;/a&gt;.&lt;/p&gt;</summary><category term="rust"></category></entry><entry><title>Cryptographic Hash Digests</title><link href="https://KieranHunt.github.io/digests.html" rel="alternate"></link><updated>2015-07-23T09:23:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-23:digests.html</id><summary type="html">&lt;p&gt;If you're anything like me then you'll love a good cryptographic hash digest. A &lt;a href="https://crates.io/crates/rust-crypto"&gt;great rust library&lt;/a&gt; makes creating digests super easy. Rust-crypto is terrific.&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;let to_be_hashed: &amp;amp;[u8] = &amp;amp;[0x0, 0x1, 0x2];&lt;/p&gt;
&lt;p&gt;let mut md5 = Md5::new();&lt;/p&gt;
&lt;p&gt;md5.input(to_be_hashed);&lt;/p&gt;
&lt;p&gt;let mut hashed =  md5.result_str();&lt;/p&gt;
&lt;p&gt;md5.reset();&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And as simply as that you've got a hash digest of whatever you want. There are &lt;a href="https://github.com/DaGenix/rust-crypto/blob/master/README.md#algorithms"&gt;a large number&lt;/a&gt; of digest functions to choose from too.&lt;/p&gt;</summary><category term="rust"></category></entry><entry><title>getters and setters</title><link href="https://KieranHunt.github.io/getters-and-setters.html" rel="alternate"></link><updated>2015-07-20T22:13:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-20:getters-and-setters.html</id><summary type="html">&lt;p&gt;I have a fair amount of experience writing Java code. &lt;a href="https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html"&gt;One of the Java patterns&lt;/a&gt; is to create classes with private fields which are accessed and modified via publicly available methods. This seemed like a good idea to me as it increases the granularity of access to the field and allows for variables to be checked before they are altered and altered before they are checked.&lt;/p&gt;
&lt;p&gt;I tried to implement this same idea in Rust but found myself wrestling with the borrow checker, struggling to come to grips with ownership and how variables seem to come in and out of scope very quickly. Online I found some discussion on the topic but &lt;a href="http://hermanradtke.com/2015/01/14/getters-functions-in-rust.html"&gt;this&lt;/a&gt; page had what I was looking for. I quickly implemented &lt;a href="https://twitter.com/hermanradtke"&gt;his&lt;/a&gt; suggestion.&lt;/p&gt;
&lt;p&gt;I began to find again that using the getters and setters was only proving to be more of a pain. Once again I hopped onto the IRC channel and asked about people's feelings there. The rustaceans on IRC agreed that getters and setters were generally not used in rust (save for a few places in the std library) but were not an anti-pattern. The few libraries that I have looked over seem to not use the getter/setter pattern either.&lt;/p&gt;
&lt;p&gt;I've elected to not use getters and setters in my own code. I'll probably revisit this problem later.&lt;/p&gt;</summary><category term="rust"></category></entry><entry><title>Rusty Radio - The first Rust-lang Podcast</title><link href="https://KieranHunt.github.io/rusty-radio.html" rel="alternate"></link><updated>2015-07-17T20:10:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-17:rusty-radio.html</id><summary type="html">&lt;p&gt;I love my podcasts and this being Rust's first podcast means that I just had to try it. It features a great mix of speakers from the rust world; many of whom are on the core team. Both of the first two episodes are long enough to allow for some pretty in depth discussion about a few topics each. The topics, so far, have generally related to libraries that the speakers themselves have been working on (both within the core of the rust language and outside of it). This leads to a hearty mix of language-specific topics as well interesting discussions on the new libraries coming out daily. The hosts of the show do a great job of steering the conversation so that even a Rust novice (such as myself) may follow.&lt;/p&gt;
&lt;p&gt;My only qualm? The lack of podcast logo means that it looks very ugly in my podcatcher.&lt;/p&gt;
&lt;p&gt;Find the show &lt;a href="http://rustyrad.io/"&gt;here&lt;/a&gt;.&lt;/p&gt;</summary><category term="rust"></category></entry><entry><title>Converting a String of Binary to an Integer</title><link href="https://KieranHunt.github.io/binary-string-to-int.html" rel="alternate"></link><updated>2015-07-17T12:55:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-17:binary-string-to-int.html</id><summary type="html">&lt;p&gt;Earlier in the week I needed to take four &lt;code&gt;u8&lt;/code&gt;s assembled in a &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt; and combine them to form a &lt;code&gt;u32&lt;/code&gt;. The tricky part was that the needed to be concatenated and then converted in binary form.&lt;/p&gt;
&lt;p&gt;Documentation seems a little scarce on the topic and what I could find either had to cast an integer represented in decimal or no longer existed. I'm looking at you &lt;code&gt;std::num::from_str_radix&lt;/code&gt;. I leapt onto the &lt;a href="https://client01.chat.mibbit.com/?server=irc.mozilla.org&amp;amp;channel=%23rust"&gt;IRC&lt;/a&gt; to ask there.&lt;/p&gt;
&lt;p&gt;Turns out that &lt;code&gt;from_str_radix&lt;/code&gt; wasn't that far off and it seems to have been refactored to another place in the codebase. Without further ado:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u32::from_str_radix(somestr, 2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This turns a (correctly formatted) string slice into a integer, or floating point, of your choosing: &lt;a href="https://doc.rust-lang.org/std/primitive.u8.html#method.from_str_radix"&gt;u8&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.u16.html#method.from_str_radix"&gt;u16&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.u32.html#method.from_str_radix"&gt;u32&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.u64.html#method.from_str_radix"&gt;u64&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.i8.html#method.from_str_radix"&gt;i8&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.i16.html#method.from_str_radix"&gt;i16&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.i32.html#method.from_str_radix"&gt;i32&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.i64.html#method.from_str_radix"&gt;i64&lt;/a&gt;, &lt;a href="https://doc.rust-lang.org/std/primitive.f32.html#method.from_str_radix"&gt;f32&lt;/a&gt; or &lt;a href="https://doc.rust-lang.org/std/primitive.f64.html#method.from_str_radix"&gt;f64&lt;/a&gt;.&lt;/p&gt;</summary><category term="rust"></category></entry><entry><title>cargo new website --bin</title><link href="https://KieranHunt.github.io/first-post.html" rel="alternate"></link><updated>2015-07-17T11:31:00+02:00</updated><author><name>Kieran Hunt</name></author><id>tag:KieranHunt.github.io,2015-07-17:first-post.html</id><summary type="html">&lt;p&gt;Its all a lie! Well some of it is at least. No this website was in &lt;a href="http://arewewebyet.com/"&gt;no way created&lt;/a&gt; using Rust.&lt;/p&gt;
&lt;p&gt;This is going to be the dumping ground for all of my Rust-related thoughts, ideas and discoveries. Feel free to &lt;a href="/feeds/all.atom.xml"&gt;subscribe&lt;/a&gt;.&lt;/p&gt;</summary><category term="rust"></category></entry></feed>